# HTTP

- http 响应  
  网页中有很多 http 响应  
  静态资源 耗时  
  - html 文件
  - 图片  
  req, res 
  readFile  setHeader  res.end(file)  
  存在的问题：文件在传输过程中一直在请求和响应，没有缓存  
  1. 浏览器端会缓存一些文件，以便下次更快的打开  
     如果后端图片没有改变，浏览器没必要发送请求
  2. 服务器端的图片不怎么会变，没必要再次去传输，节省带宽资源  
     如果用户修改了图片，一定要通知浏览器重新下载  

- etag   
  服务器根据当前文件内容，生成唯一标识，只要内容不变，就不需要重复传输  

- 缓存文件，节省服务器的带宽，客户端直接使用浏览器缓存的文件 --- etag  
  1. 服务器端返回文件的同时，在 http 响应头中带有 Etag = 'ffff' 的值，作为该文件的唯一标识 
  2. 浏览器再次请求文件时 Request Headers 中带有 If-None-Match  
     http 协议(1.0/1.1 2.0) If-None-Match  
     浏览器有响应的缓存，但浏览器不知道要直接用，要询问服务器端是否有改动，没有改动就直接用缓存的文件   
     浏览器端的请求头 Request Headers 通过 If-None-Match == 'ffff' 判断是否改动  


# 小结  
  文件缓存节省带宽：
  1. 服务器端发送的时候在请求头中设置 Etag 作为文件的唯一标识  
  2. 浏览器请求的时候请求头 Request Header 中会带有 if-none-match 作为判断  
     如果请求头中没有带有 if-none-match 说明是第一次请求，服务器端读取文件输出给浏览器 --- 消耗完整带宽  
  3. 如果请求头中带有 if-none-match 说明不是第一次请求，就要判断文件是否修改过  
     服务器端比较请求头中的 if-none-match 和 Etag：  
     如果相同，表示文件未修改，服务器端 res.writeHead('304'); 使用状态码 304 告诉浏览器文件未修改，返回空，直接使用缓存文件  
     如果不同，服务器端重新读取并传送该文件


# http 状态码  
HTTP状态码总的分为五类： 

1开头：信息状态码  

2开头：成功状态码  

3开头：重定向状态码  

4开头：客户端错误状态码  

5开头：服务端错误状态码  